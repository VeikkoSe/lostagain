<!DOCTYPE html>
<html>
<head lang="en">
    <script id="2d-vertex-shader" type="x-shader/x-vertex">

			attribute vec3 aVertexPosition;
			attribute vec4 aVertexColor;

			varying lowp vec4 vColor;

			void main(void) {
				gl_Position = vec4(aVertexPosition, 1.0);

				vColor = aVertexColor;
			}
		</script>

    <script id="2d-fragment-shader" type="x-shader/x-fragment">

			varying lowp vec4 vColor;

			void main(void) {
				gl_FragColor = vColor;
			}
		</script>

    <canvas id="mycanvas" width="500" height="500"></canvas>





    <script>
        var canvas;
        var gl;
        var triangleProgram;

        var convertedVerts = [];
        var vertColors = [];

        var vertexPositionAttribute;
        var vertexColorAttribute;

        var verticesBuffer;

        window.onload = function() {

            canvas = document.getElementById('mycanvas');

            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            //gl.enable(gl.DEPTH_TEST); // to do proper z-index, set this

            // these are the settings for basic overlay transparency
            gl.disable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            var vertexShaderHandle = gl.createShader(gl.VERTEX_SHADER);
            var fragmentShaderHandle = gl.createShader(gl.FRAGMENT_SHADER);

            gl.shaderSource(vertexShaderHandle, document.getElementById('2d-vertex-shader').text);
            gl.shaderSource(fragmentShaderHandle, document.getElementById('2d-fragment-shader').text);

            gl.compileShader(vertexShaderHandle);
            gl.compileShader(fragmentShaderHandle);

            triangleProgram = gl.createProgram();
            gl.attachShader(triangleProgram, vertexShaderHandle);
            gl.attachShader(triangleProgram, fragmentShaderHandle);
            gl.linkProgram(triangleProgram);

            gl.useProgram(triangleProgram);

            verticesBuffer = gl.createBuffer();

            vertexPositionAttribute = gl.getAttribLocation(triangleProgram, "aVertexPosition");
            gl.enableVertexAttribArray(vertexPositionAttribute);

            vertexColorAttribute = gl.getAttribLocation(triangleProgram, "aVertexColor");
            gl.enableVertexAttribArray(vertexColorAttribute);

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0.5, 0, 1);

            /*
             setInterval(function(){
             drawShapes();
             render();
             }, 1000/60);
             */

            drawShapes();
            render();

        };

        function drawShapes() {
            convertedVerts = [];

            for(var i = 0; i < 10; i++) {
                var offsetX = Math.random() * canvas.width;
                var offsetY = Math.random() * canvas.height;

                var randRed = parseInt(Math.random() * 255);
                var randGreen = parseInt(Math.random() * 255);
                var randBlue = parseInt(Math.random() * 255);

                drawTriangle(getRandCoords(offsetX, offsetY), getRandCoords(offsetX, offsetY), getRandCoords(offsetX, offsetY), getColor('rgba(' + randRed + ',' + randGreen + ',' + randBlue + ',1.0)'), parseInt(Math.random() * 100));
            }
        }

        function getRandCoords(offsetX, offsetY) {
            return [Math.random() * 50 + offsetX, Math.random() * 50 + offsetY];
        }

        function drawTriangle(p1, p2, p3, color, zIndex) {
            zIndex = convertRange(0, canvas.height, 0.999, 0, zIndex);

            var pxVerts = [ p1, p2, p3 ];

            convertedVerts = convertedVerts.concat(getConvertedVerts(pxVerts, zIndex, color));
        }

        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            var itemSize = 7; // x,y,z + r,g,b,a
            var numItems = convertedVerts.length / itemSize;

            gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(convertedVerts), gl.DYNAMIC_DRAW);

            var step = Float32Array.BYTES_PER_ELEMENT;
            var total = 3 + 4;
            var stride = step * total;
            gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, stride, 0);
            gl.vertexAttribPointer(vertexColorAttribute, 4, gl.FLOAT, false, stride, step * 3);

            gl.drawArrays(gl.TRIANGLES, 0, numItems);
        }

        // converts an array of px values into an array of -1.0 to 1.0  floats
        function getConvertedVerts(pxVerts, zIndex, color) {
            var convertedVerts = [];

            for(var i = 0; i < pxVerts.length; i++) {
                var coords = pxVerts[i];

                var x = coords[0];
                x = convertRange(0, canvas.width, -1.0, 1.0, x);

                var y = coords[1];
                y = convertRange(0, canvas.height, 1.0, -1.0, y);

                convertedVerts.push(x);
                convertedVerts.push(y);
                convertedVerts.push(zIndex);

                convertedVerts.push(color[0]);
                convertedVerts.push(color[1]);
                convertedVerts.push(color[2]);
                convertedVerts.push(color[3]);
            }

            return convertedVerts;
        }

        // converts CSS style rgba string into an array of floats from 0.0 to 1.0;
        function getColor(color) {
            var colorArr = color.replace('rgba(','').replace(')','').split(',');

            var r = parseInt(colorArr[0]);
            var g = parseInt(colorArr[1]);
            var b = parseInt(colorArr[2]);
            var a = parseFloat(colorArr[3]);

            r = convertRange(0, 255, 0.0, 1.0, r);
            g = convertRange(0, 255, 0.0, 1.0, g);
            b = convertRange(0, 255, 0.0, 1.0, b);

            var colorFloats = [r, g, b, a];

            return colorFloats;
        }

        // http://stackoverflow.com/questions/929103/convert-a-number-range-to-another-range-maintaining-ratio
        function convertRange(OldMin, OldMax, NewMin, NewMax, OldValue) {
            var OldRange = (OldMax - OldMin);

            if (OldRange == 0) {
                var NewValue = NewMin;
            } else {
                var NewRange = (NewMax - NewMin);
                var NewValue = (((OldValue - OldMin) * NewRange) / OldRange) + NewMin;
            }

            return NewValue;
        }
    </script>
</head>
<body>
<canvas id="mycanvas"></canvas>
</body>
</html>